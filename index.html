<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no"/>
  <title>Ball Blast 2D (Canvas)</title>
  <style>
    html,body{margin:0;height:100%;background:#7ad9ff;overflow:hidden;touch-action:none}
    canvas{display:block;width:100vw;height:100vh}
    .ui{
      position:fixed;left:12px;top:12px;z-index:10;
      font:800 13px/1.25 system-ui,-apple-system,Segoe UI,Roboto,Arial;
      color:rgba(255,255,255,.96);
      background:rgba(0,0,0,.18);
      border:1px solid rgba(255,255,255,.22);
      border-radius:14px;padding:10px 12px;
      backdrop-filter: blur(10px);
      box-shadow:0 10px 30px rgba(0,0,0,.18);
      white-space:pre;
      pointer-events:none;
    }
    .hint{
      position:fixed;left:12px;bottom:12px;z-index:10;
      font:700 12px/1.2 system-ui,-apple-system,Segoe UI,Roboto,Arial;
      color:rgba(255,255,255,.92);
      background:rgba(0,0,0,.16);
      border:1px solid rgba(255,255,255,.20);
      border-radius:14px;padding:10px 12px;
      backdrop-filter: blur(10px);
      box-shadow:0 10px 30px rgba(0,0,0,.16);
      pointer-events:none;
    }
  </style>
</head>
<body>
  <div class="ui" id="hud">Loading…</div>
  <div class="hint">Тяни палец — двигай пушку • Стрельба авто</div>
  <canvas id="c"></canvas>

<script>
(() => {
  const canvas = document.getElementById('c');
  const hud = document.getElementById('hud');

  // ---------- crisp scaling (no blur)
  let DPR = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
  let W=0,H=0;

  function resize(){
    DPR = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
    W = Math.floor(window.innerWidth);
    H = Math.floor(window.innerHeight);
    canvas.width  = Math.floor(W * DPR);
    canvas.height = Math.floor(H * DPR);
    canvas.style.width = W+'px';
    canvas.style.height = H+'px';
    ctx.setTransform(DPR,0,0,DPR,0,0);
  }

  const ctx = canvas.getContext('2d', { alpha:false, desynchronized:true });
  ctx.imageSmoothingEnabled = false;

  window.addEventListener('resize', resize, {passive:true});
  resize();

  // ---------- helpers
  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  const rand=(a,b)=>a+Math.random()*(b-a);

  // ---------- game state
  const state = {
    level: 1,
    stage: 1,
    score: 0,
    coins: 0,
    best: Number(localStorage.getItem('bb_best2d')||0),

    dmg: 1,
    fireRate: 12, // shots/sec
    bulletSpeed: 900,

    hpMax: 3,
    hp: 3,

    lastShot: 0,
    paused: false,
    gameOver: false,
  };

  const world = {
    groundY: () => H - 92,
    dangerY: () => H - 92 + 34, // line where balls bounce; damage only when they touch this line
  };

  // cannon
  const cannon = {
    x: W/2,
    y: () => world.groundY(),
    minX: 42,
    maxX: () => W-42,
    dragging: false
  };

  // entities
  const bullets = [];
  const balls = [];
  const coinDrops = [];

  function addBall(x,y,r,hp,vx,vy){
    balls.push({x,y,r,hp,vx,vy, hitFlash:0});
  }

  function spawnLevel(lvl){
    bullets.length=0;
    balls.length=0;
    coinDrops.length=0;

    const count = clamp(3 + Math.floor(lvl*0.35), 3, 10);
    const baseHP = 6 + Math.floor(lvl*1.2);

    for(let i=0;i<count;i++){
      const r = rand(22, 44);
      const x = rand(r+12, W - r - 12);
      const y = rand(120, 260);
      const hp = Math.max(1, baseHP + Math.floor(rand(-4,9)));
      addBall(x,y,r,hp, rand(-90,90), rand(-40,40));
    }
    state.hp = state.hpMax;
  }

  spawnLevel(state.level);

  // ---------- input
  function setCannonX(x){
    cannon.x = clamp(x, cannon.minX, cannon.maxX());
  }

  canvas.addEventListener('pointerdown', (e)=>{
    if (state.gameOver) { location.reload(); return; }
    if (state.paused) return;
    cannon.dragging = true;
    setCannonX(e.clientX);
  }, {passive:true});

  canvas.addEventListener('pointermove', (e)=>{
    if (!cannon.dragging || state.paused) return;
    setCannonX(e.clientX);
  }, {passive:true});

  const endDrag = ()=>{ cannon.dragging=false; };
  canvas.addEventListener('pointerup', endDrag, {passive:true});
  canvas.addEventListener('pointercancel', endDrag, {passive:true});

  // ---------- mechanics
  function shoot(now){
    const interval = 1000/state.fireRate;
    if (now - state.lastShot < interval) return;
    state.lastShot = now;

    bullets.push({
      x: cannon.x,
      y: cannon.y() - 56,
      vy: -state.bulletSpeed,
      life: 1.25
    });
  }

  function dropCoins(x,y,amount){
    const n = clamp(Math.floor(amount/2), 1, 6);
    for(let i=0;i<n;i++){
      coinDrops.push({
        x, y,
        vx: rand(-130,130),
        vy: rand(-320,-180),
        g: 820,
        life: 2.2
      });
    }
  }

  function splitBall(ball){
    // split only if big enough
    if (ball.r < 26) return;

    const newR = ball.r * 0.68;
    const hpEach = Math.max(1, Math.floor(ball.hp/2));
    const speedBoost = 1.15;

    addBall(ball.x - newR*0.6, ball.y, newR, hpEach, -Math.abs(ball.vx)*speedBoost - 70, -180);
    addBall(ball.x + newR*0.6, ball.y, newR, hpEach,  Math.abs(ball.vx)*speedBoost + 70, -180);
  }

  function levelClear(){
    // reward + next
    state.best = Math.max(state.best, state.score);
    localStorage.setItem('bb_best2d', String(state.best));

    // simple upgrade pick (for now: auto)
    // дальше сделаем красивый UI с карточками, сундуком, редкостями
    state.coins += 40 + Math.floor(state.level*4);
    // auto small progression
    if (state.level % 2 === 0) state.dmg += 1;
    if (state.level % 3 === 0) state.fireRate = Math.min(22, state.fireRate + 1);

    state.level++;
    if (state.level % 10 === 1 && state.level>1) state.stage++;

    spawnLevel(state.level);
  }

  // ---------- rendering
  function drawBackground(){
    // sky
    ctx.fillStyle = '#7ad9ff';
    ctx.fillRect(0,0,W,H);

    // mountains
    ctx.globalAlpha = 0.55;
    ctx.fillStyle = '#43bce9';
    ctx.beginPath();
    ctx.moveTo(40, H*0.67);
    ctx.lineTo(W*0.35, H*0.18);
    ctx.lineTo(W*0.62, H*0.67);
    ctx.closePath();
    ctx.fill();

    ctx.beginPath();
    ctx.moveTo(W*0.24, H*0.74);
    ctx.lineTo(W*0.55, H*0.30);
    ctx.lineTo(W*0.92, H*0.74);
    ctx.closePath();
    ctx.fill();

    ctx.globalAlpha = 1;

    // ground
    ctx.fillStyle = '#70d65f';
    ctx.fillRect(0, world.groundY()+40, W, H-(world.groundY()+40));

    // ground line
    ctx.globalAlpha = 0.18;
    ctx.strokeStyle = '#2a2f3a';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(0, world.groundY()+40);
    ctx.lineTo(W, world.groundY()+40);
    ctx.stroke();
    ctx.globalAlpha = 1;

    // danger line (invisible in final, but keep subtle)
    ctx.globalAlpha = 0.06;
    ctx.strokeStyle = '#000';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(0, world.dangerY());
    ctx.lineTo(W, world.dangerY());
    ctx.stroke();
    ctx.globalAlpha = 1;
  }

  function drawCannon(){
    const x = cannon.x, y = cannon.y();

    // wheels
    ctx.fillStyle = '#1b1f28';
    ctx.beginPath(); ctx.arc(x-26, y+26, 14, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(x+26, y+26, 14, 0, Math.PI*2); ctx.fill();
    ctx.globalAlpha = 0.18;
    ctx.strokeStyle = '#fff'; ctx.lineWidth = 2;
    ctx.beginPath(); ctx.arc(x-26, y+26, 14, 0, Math.PI*2); ctx.stroke();
    ctx.beginPath(); ctx.arc(x+26, y+26, 14, 0, Math.PI*2); ctx.stroke();
    ctx.globalAlpha = 1;

    // base
    ctx.fillStyle = '#2a2f3a';
    roundRect(x-40, y+18, 80, 34, 10, true);
    ctx.globalAlpha = 0.22;
    ctx.strokeStyle = '#fff'; ctx.lineWidth = 2;
    roundRect(x-40, y+18, 80, 34, 10, false, true);
    ctx.globalAlpha = 1;

    // barrel
    ctx.fillStyle = '#cfd6e4';
    roundRect(x-9, y-34, 18, 56, 8, true);
    ctx.globalAlpha = 0.14;
    ctx.strokeStyle = '#000'; ctx.lineWidth = 2;
    roundRect(x-9, y-34, 18, 56, 8, false, true);
    ctx.globalAlpha = 1;

    // muzzle flash tiny
    ctx.globalAlpha = 0.18;
    ctx.fillStyle = '#ffb100';
    ctx.beginPath(); ctx.arc(x, y-40, 12, 0, Math.PI*2); ctx.fill();
    ctx.globalAlpha = 1;
  }

  function roundRect(x,y,w,h,r,fill=false,stroke=false){
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr, y);
    ctx.arcTo(x+w, y, x+w, y+h, rr);
    ctx.arcTo(x+w, y+h, x, y+h, rr);
    ctx.arcTo(x, y+h, x, y, rr);
    ctx.arcTo(x, y, x+w, y, rr);
    ctx.closePath();
    if (fill) ctx.fill();
    if (stroke) ctx.stroke();
  }

  function drawBall(ball){
    const {x,y,r,hp} = ball;

    // fill
    ctx.fillStyle = '#2ecc71';
    ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();

    // stroke
    ctx.globalAlpha = 0.25;
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 4;
    ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.stroke();
    ctx.globalAlpha = 1;

    // hit flash
    if (ball.hitFlash > 0){
      ctx.globalAlpha = clamp(ball.hitFlash,0,1) * 0.22;
      ctx.fillStyle = '#ffffff';
      ctx.beginPath(); ctx.arc(x,y,r*1.02,0,Math.PI*2); ctx.fill();
      ctx.globalAlpha = 1;
    }

    // hp text
    ctx.fillStyle = '#fff';
    ctx.font = `${Math.round(r*0.82)}px system-ui,-apple-system,Segoe UI,Roboto,Arial`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(String(hp), x, y+1);
  }

  function drawBullet(b){
    ctx.fillStyle = '#fff';
    ctx.beginPath();
    ctx.arc(b.x, b.y, 4, 0, Math.PI*2);
    ctx.fill();
  }

  function drawCoin(c){
    ctx.fillStyle = '#ffd33d';
    ctx.beginPath(); ctx.arc(c.x, c.y, 7, 0, Math.PI*2); ctx.fill();
    ctx.globalAlpha = 0.25;
    ctx.strokeStyle = '#fff'; ctx.lineWidth = 2;
    ctx.beginPath(); ctx.arc(c.x, c.y, 7, 0, Math.PI*2); ctx.stroke();
    ctx.globalAlpha = 1;
  }

  function updateHud(){
    hud.textContent =
      `LEVEL: ${state.level}  STAGE: ${state.stage}\n`+
      `SCORE: ${state.score}  BEST: ${state.best}\n`+
      `COINS: ${state.coins}\n`+
      `HP: ${state.hp}/${state.hpMax}  DMG:${state.dmg}  FR:${Math.round(state.fireRate)}`;
  }

  // ---------- loop
  let last = performance.now();

  function tick(now){
    const dt = Math.min(0.033, (now - last)/1000);
    last = now;

    if (!state.paused && !state.gameOver){
      // shoot
      shoot(now);

      // bullets update
      for (let i=bullets.length-1;i>=0;i--){
        const b = bullets[i];
        b.y += b.vy * dt;
        b.life -= dt;
        if (b.life<=0 || b.y < -40) bullets.splice(i,1);
      }

      // balls update
      for (let i=balls.length-1;i>=0;i--){
        const ball = balls[i];

        ball.x += ball.vx * dt;
        ball.y += ball.vy * dt;

        // gravity
        ball.vy += 280 * dt;

        // walls
        if (ball.x - ball.r < 0){ ball.x = ball.r; ball.vx *= -1; }
        if (ball.x + ball.r > W){ ball.x = W - ball.r; ball.vx *= -1; }

        // ceiling
        if (ball.y - ball.r < 80){ ball.y = 80 + ball.r; ball.vy *= -1; }

        // ground bounce + DAMAGE ONLY ON REAL TOUCH
        const dy = world.dangerY();
        if (ball.y + ball.r >= dy){
          // touch
          ball.y = dy - ball.r;
          // only damage if it was moving downward (real hit)
          if (ball.vy > 120){
            state.hp -= 1;
            if (navigator.vibrate) navigator.vibrate(15);
            if (state.hp <= 0){
              state.gameOver = true;
              state.best = Math.max(state.best, state.score);
              localStorage.setItem('bb_best2d', String(state.best));
            }
          }
          ball.vy *= -0.78;
        }

        ball.hitFlash = Math.max(0, ball.hitFlash - dt*6);
      }

      // coins update
      for (let i=coinDrops.length-1;i>=0;i--){
        const c = coinDrops[i];
        c.x += c.vx * dt;
        c.y += c.vy * dt;
        c.vy += c.g * dt;
        c.life -= dt;

        const gy = world.dangerY();
        if (c.y >= gy){
          c.y = gy;
          c.vy *= -0.45;
          c.vx *= 0.85;
          if (Math.abs(c.vy) < 35) c.vy = 0;
        }

        // collect
        const d = Math.hypot(c.x - cannon.x, c.y - (cannon.y()+22));
        if (d < 44){
          state.coins += 1;
          coinDrops.splice(i,1);
          continue;
        }

        if (c.life<=0) coinDrops.splice(i,1);
      }

      // bullet-ball collisions
      for (let bi=bullets.length-1; bi>=0; bi--){
        const b = bullets[bi];
        let hitIndex = -1;

        for (let i=0;i<balls.length;i++){
          const ball = balls[i];
          const d = Math.hypot(b.x - ball.x, b.y - ball.y);
          if (d <= ball.r + 6){ hitIndex = i; break; }
        }

        if (hitIndex !== -1){
          const ball = balls[hitIndex];
          ball.hp -= state.dmg;
          state.score += state.dmg;
          ball.hitFlash = 1;

          // remove bullet
          bullets.splice(bi,1);

          if (ball.hp <= 0){
            // reward + split
            state.coins += 5 + Math.floor(state.level/2);
            dropCoins(ball.x, ball.y, 12 + state.level);
            splitBall(ball);
            balls.splice(hitIndex,1);
          }
        }
      }

      // clear
      if (balls.length === 0 && !state.gameOver){
        levelClear();
      }

      updateHud();
    }

    // ---------- render
    drawBackground();

    // bullets
    for (const b of bullets) drawBullet(b);

    // balls
    for (const ball of balls) drawBall(ball);

    // coins
    for (const c of coinDrops) drawCoin(c);

    // cannon
    drawCannon();

    // game over overlay
    if (state.gameOver){
      ctx.globalAlpha = 0.42;
      ctx.fillStyle = '#000';
      ctx.fillRect(0,0,W,H);
      ctx.globalAlpha = 1;

      ctx.fillStyle = '#fff';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.font = '800 30px system-ui,-apple-system,Segoe UI,Roboto,Arial';
      ctx.fillText('GAME OVER', W/2, H/2 - 18);
      ctx.font = '700 14px system-ui,-apple-system,Segoe UI,Roboto,Arial';
      ctx.fillStyle = 'rgba(255,255,255,.9)';
      ctx.fillText('Tap to restart', W/2, H/2 + 20);
    }

    requestAnimationFrame(tick);
  }

  requestAnimationFrame(tick);
})();
</script>
</body>
</html>
