<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no" />
  <title>Arena Defense</title>
  <style>
    html, body { margin:0; padding:0; background:#07060a; height:100%; overflow:hidden; touch-action:none; }
    #game { width:100vw; height:100vh; }

    /* мини-премиум HUD */
    .hud {
      position: fixed; left: 12px; top: 12px; z-index: 20;
      font: 700 13px/1.2 system-ui, -apple-system, Segoe UI, Roboto, Arial;
      color: rgba(255,255,255,.92);
      background: rgba(18,14,26,.55);
      border: 1px solid rgba(180,120,255,.25);
      padding: 10px 12px; border-radius: 14px;
      backdrop-filter: blur(10px);
      pointer-events: none;
      max-width: 78vw;
      box-shadow: 0 12px 40px rgba(0,0,0,.35);
    }
    .tip {
      position: fixed; left: 12px; bottom: 12px; z-index: 20;
      font: 600 12px/1.2 system-ui, -apple-system, Segoe UI, Roboto, Arial;
      color: rgba(255,255,255,.85);
      background: rgba(18,14,26,.45);
      border: 1px solid rgba(255,102,245,.18);
      padding: 10px 12px; border-radius: 14px;
      backdrop-filter: blur(10px);
      pointer-events: none;
      box-shadow: 0 12px 40px rgba(0,0,0,.35);
    }
  </style>
</head>
<body>
  <div class="hud" id="hud">Loading...</div>
  <div class="tip">ЛЕВО: джойстик • ПРАВО: УЛЬТА • Стрельба авто</div>

  <div id="game"></div>

  <!-- Phaser CDN -->
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.80.1/dist/phaser.min.js"></script>

  <script>
    // ===== util
    function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }
    function dist(ax,ay,bx,by){ const dx=ax-bx, dy=ay-by; return Math.hypot(dx,dy); }

    class GameScene extends Phaser.Scene {
      constructor(){ super('game'); }

      create(){
        // safe area-ish
        this.W = this.scale.width;
        this.H = this.scale.height;

        // arena rect
        this.arena = { x: 18, y: 78, w: this.W - 36, h: this.H - 126 };
        this.center = { x: this.arena.x + this.arena.w/2, y: this.arena.y + this.arena.h/2 };

        // background
        this.bg = this.add.graphics();
        this.drawArena();

        // state
        this.hpMax = 100;
        this.hp = this.hpMax;
        this.xp = 0;
        this.level = 1;
        this.wave = 1;
        this.kills = 0;

        // shooting
        this.fireRate = 8;      // bullets per sec
        this.bulletSpeed = 620;
        this.damage = 12;
        this.range = 520;
        this.lastShot = 0;

        // ultimate
        this.ultCharge = 0;     // 0..1
        this.ultReady = false;
        this.ultCooldown = 0;   // seconds remaining (visual)
        this.ultName = "NOVA";

        // groups
        this.bullets = this.add.group();
        this.enemies = this.add.group();
        this.particles = this.add.group();
        this.floating = this.add.group();

        // player
        this.player = this.add.circle(this.center.x, this.center.y, 14, 0x9b5cff, 1);
        this.player.setStrokeStyle(2, 0xff66f5, 0.35);
        this.player.inv = 0;

        // mobile controls
        this.leftPointerId = null;
        this.rightPointerId = null;
        this.joyStart = null;
        this.joyVec = new Phaser.Math.Vector2(0,0);

        // ult button zone (right side)
        this.ultZone = { x: this.W*0.62, y: this.H*0.58, w: this.W*0.38, h: this.H*0.42 };

        this.input.on('pointerdown', (p)=>{
          if (p.x < this.W*0.55 && this.leftPointerId === null){
            this.leftPointerId = p.id;
            this.joyStart = new Phaser.Math.Vector2(p.x, p.y);
            this.joyVec.set(0,0);
          } else if (this.rightPointerId === null){
            this.rightPointerId = p.id;
            this.tryUltimate(); // right tap = ult
          }
        });

        this.input.on('pointermove', (p)=>{
          if (p.id === this.leftPointerId && this.joyStart){
            const dx = p.x - this.joyStart.x;
            const dy = p.y - this.joyStart.y;
            const v = new Phaser.Math.Vector2(dx, dy);
            const len = v.length();
            const max = 72;
            if (len > max) v.scale(max / len);
            this.joyVec = v.scale(1 / max);
          }
        });

        const endPointer = (p)=>{
          if (p.id === this.leftPointerId){
            this.leftPointerId = null;
            this.joyStart = null;
            this.joyVec.set(0,0);
          }
          if (p.id === this.rightPointerId){
            this.rightPointerId = null;
          }
        };
        this.input.on('pointerup', endPointer);
        this.input.on('pointerout', endPointer);
        this.input.on('pointercancel', endPointer);

        // spawn system
        this.waveAliveTarget = 0;
        this.waveSpawned = 0;
        this.spawnTimer = 0;
        this.waveIntro();

        // upgrade overlay (simple, premium style)
        this.upgradeOpen = false;
        this.upgradeUI = null;

        // hud
        this.hudEl = document.getElementById('hud');
        this.updateHud();

        // subtle screen vignette-ish
        this.vignette = this.add.graphics();
        this.drawVignette();

        // resize
        this.scale.on('resize', (gameSize)=>{
          this.W = gameSize.width;
          this.H = gameSize.height;
          this.arena = { x: 18, y: 78, w: this.W - 36, h: this.H - 126 };
          this.center = { x: this.arena.x + this.arena.w/2, y: this.arena.y + this.arena.h/2 };
          this.ultZone = { x: this.W*0.62, y: this.H*0.58, w: this.W*0.38, h: this.H*0.42 };
          this.drawArena(true);
          this.drawVignette(true);
        });
      }

      drawArena(clear=false){
        if (clear) this.bg.clear();
        const g = this.bg;
        g.fillStyle(0x0f0b16, 1);
        g.fillRoundedRect(this.arena.x, this.arena.y, this.arena.w, this.arena.h, 18);

        // neon border
        g.lineStyle(2, 0x8a4dff, 0.22);
        g.strokeRoundedRect(this.arena.x, this.arena.y, this.arena.w, this.arena.h, 18);

        // faint inner grid lines
        g.lineStyle(1, 0xff66f5, 0.06);
        for (let i=1;i<5;i++){
          const x = this.arena.x + (this.arena.w/5)*i;
          const y = this.arena.y + (this.arena.h/5)*i;
          g.lineBetween(x, this.arena.y+10, x, this.arena.y+this.arena.h-10);
          g.lineBetween(this.arena.x+10, y, this.arena.x+this.arena.w-10, y);
        }

        // ultimate button hint ring (bottom-right)
        g.fillStyle(0xff66f5, 0.06);
        g.fillCircle(this.W - 74, this.H - 74, 56);
        g.lineStyle(2, 0xff66f5, 0.16);
        g.strokeCircle(this.W - 74, this.H - 74, 56);
      }

      drawVignette(clear=false){
        if (clear) this.vignette.clear();
        const g = this.vignette;
        g.fillStyle(0x000000, 0.18);
        g.fillRect(0,0,this.W,this.H);
        // punch hole for arena (fake vignette)
        g.clear();
        // actually create edge shadow by drawing rects
        const pad = 0;
        const thickness = 26;
        g.fillStyle(0x000000, 0.22);
        g.fillRect(pad, pad, this.W, thickness);
        g.fillRect(pad, this.H-thickness, this.W, thickness);
        g.fillRect(pad, pad, thickness, this.H);
        g.fillRect(this.W-thickness, pad, thickness, this.H);
      }

      clampToArena(obj){
        obj.x = clamp(obj.x, this.arena.x + 16, this.arena.x + this.arena.w - 16);
        obj.y = clamp(obj.y, this.arena.y + 16, this.arena.y + this.arena.h - 16);
      }

      waveIntro(){
        // wave scaling
        this.waveAliveTarget = 6 + Math.floor(this.wave * 2.2);
        this.waveSpawned = 0;
        this.spawnTimer = 0;

        // small banner
        const t = this.add.text(this.W/2, 36, `WAVE ${this.wave}`, {
          fontFamily:'system-ui, -apple-system, Segoe UI, Roboto, Arial',
          fontSize:'20px',
          color:'#ffffff'
        }).setOrigin(0.5).setAlpha(0);
        this.tweens.add({
          targets:t, alpha:0.95, y: 30, duration:140, yoyo:true, hold:450,
          onComplete:()=>t.destroy()
        });
      }

      spawnEnemy(){
        // spawn at arena edge
        const side = Phaser.Math.Between(0,3);
        let x, y;
        const m = 12;
        if (side === 0){ x = Phaser.Math.Between(this.arena.x+m, this.arena.x+this.arena.w-m); y = this.arena.y+m; }
        if (side === 1){ x = Phaser.Math.Between(this.arena.x+m, this.arena.x+this.arena.w-m); y = this.arena.y+this.arena.h-m; }
        if (side === 2){ x = this.arena.x+m; y = Phaser.Math.Between(this.arena.y+m, this.arena.y+this.arena.h-m); }
        if (side === 3){ x = this.arena.x+this.arena.w-m; y = Phaser.Math.Between(this.arena.y+m, this.arena.y+this.arena.h-m); }

        const e = this.add.circle(x, y, 12, 0xff4d6d, 1);
        e.setStrokeStyle(2, 0xffb3c0, 0.22);

        // scale enemy stats per wave
        e.hpMax = 30 + this.wave * 8;
        e.hp = e.hpMax;
        e.spd = 56 + this.wave * 2.5 + Phaser.Math.Between(0,16);
        e.dmg = 8 + Math.floor(this.wave*0.7);

        // rare tank
        if (Phaser.Math.FloatBetween(0,1) < 0.10){
          e.setScale(1.25);
          e.fillColor = 0xff3aa8;
          e.hpMax *= 1.7;
          e.hp = e.hpMax;
          e.spd *= 0.78;
          e.dmg *= 1.25;
        }

        this.enemies.add(e);
      }

      findNearestEnemy(){
        let best = null;
        let bestD = Infinity;
        const px = this.player.x, py = this.player.y;
        this.enemies.getChildren().forEach(e=>{
          if (!e.active) return;
          const d = dist(px,py,e.x,e.y);
          if (d < bestD){
            bestD = d;
            best = e;
          }
        });
        return { e: best, d: bestD };
      }

      shootAt(target){
        const px = this.player.x, py = this.player.y;
        const ang = Phaser.Math.Angle.Between(px,py,target.x,target.y);

        const b = this.add.circle(px, py, 4, 0xff66f5, 1);
        b.vx = Math.cos(ang) * this.bulletSpeed;
        b.vy = Math.sin(ang) * this.bulletSpeed;
        b.life = 1.0; // sec
        b.dmg = this.damage;
        this.bullets.add(b);

        // muzzle glow
        const m = this.add.circle(px + Math.cos(ang)*10, py + Math.sin(ang)*10, 12, 0x9b5cff, 0.14);
        this.tweens.add({ targets:m, alpha:0, scale:1.35, duration:120, onComplete:()=>m.destroy() });
      }

      pop(x,y, col=0xff66f5){
        const p = this.add.circle(x,y, 10, col, 0.18);
        p.setStrokeStyle(2, col, 0.25);
        this.tweens.add({ targets:p, alpha:0, scale:1.8, duration:180, onComplete:()=>p.destroy() });
      }

      floatText(x,y, text){
        const t = this.add.text(x,y, text, {
          fontFamily:'system-ui, -apple-system, Segoe UI, Roboto, Arial',
          fontSize:'13px',
          color:'#ffffff'
        }).setOrigin(0.5).setAlpha(0.92);
        this.tweens.add({
          targets:t, y: y-26, alpha:0, duration:520,
          onComplete:()=>t.destroy()
        });
      }

      tryUltimate(){
        if (!this.ultReady || this.upgradeOpen) return;

        this.ultReady = false;
        this.ultCharge = 0;
        this.ultCooldown = 8; // purely cosmetic timer text, recharge is via kills

        // NOVA: big ring + damage all nearby
        const px=this.player.x, py=this.player.y;
        const ring = this.add.circle(px,py, 18, 0xff66f5, 0.16);
        ring.setStrokeStyle(3, 0xff66f5, 0.35);

        this.tweens.add({
          targets:ring, scale: 12, alpha: 0, duration: 520,
          onUpdate:()=>{
            // nothing
          },
          onComplete:()=>ring.destroy()
        });

        const radius = 260;
        let hits = 0;
        this.enemies.getChildren().forEach(e=>{
          if (!e.active) return;
          const d = dist(px,py,e.x,e.y);
          if (d <= radius){
            e.hp -= (45 + this.wave*2);
            hits++;
            this.pop(e.x,e.y, 0xff66f5);
            if (e.hp <= 0){
              this.killEnemy(e);
            }
          }
        });

        this.cameras.main.shake(120, 0.006);
        if (navigator.vibrate) navigator.vibrate([20,30,20]);
        this.floatText(px, py-34, hits ? `ULT: ${hits} hits` : `ULT: miss`);
      }

      killEnemy(e){
        if (!e.active) return;
        e.destroy();

        this.kills++;
        this.xp += 8 + this.wave;

        // ult charge from kills
        this.ultCharge = clamp(this.ultCharge + 0.08, 0, 1);
        if (this.ultCharge >= 1) this.ultReady = true;

        this.pop(e.x,e.y, 0xff4d6d);
        if (Phaser.Math.FloatBetween(0,1) < 0.22) this.floatText(e.x, e.y-18, "+XP");

        // level up every ~60 xp
        const need = 60 + (this.level-1)*18;
        if (this.xp >= need){
          this.xp -= need;
          this.level++;
          this.openUpgrade();
        }
      }

      openUpgrade(){
        if (this.upgradeOpen) return;
        this.upgradeOpen = true;

        // pause spawn a bit
        const overlay = this.add.rectangle(0,0,this.W,this.H, 0x000000, 0.45).setOrigin(0);
        const card = this.add.graphics();
        const cw = Math.min(this.W - 40, 420);
        const ch = 250;
        const cx = this.W/2 - cw/2;
        const cy = this.H/2 - ch/2;

        card.fillStyle(0x141024, 0.85);
        card.fillRoundedRect(cx, cy, cw, ch, 18);
        card.lineStyle(2, 0x8a4dff, 0.22);
        card.strokeRoundedRect(cx, cy, cw, ch, 18);

        const title = this.add.text(this.W/2, cy+22, "CHOOSE UPGRADE", {
          fontFamily:'system-ui, -apple-system, Segoe UI, Roboto, Arial',
          fontSize:'16px',
          color:'#ffffff'
        }).setOrigin(0.5).setAlpha(0.95);

        // 3 upgrades
        const upgrades = this.buildUpgrades();
        const btns = [];
        for (let i=0;i<3;i++){
          const u = upgrades[i];
          const by = cy + 60 + i*58;
          const bx = cx + 16;
          const bw = cw - 32;
          const bh = 46;

          const r = this.add.rectangle(bx, by, bw, bh, 0x000000, 0.01).setOrigin(0);
          r.setStrokeStyle(1, 0xff66f5, 0.16);

          const name = this.add.text(bx+14, by+12, u.name, {
            fontFamily:'system-ui, -apple-system, Segoe UI, Roboto, Arial',
            fontSize:'14px',
            color:'#ffffff'
          }).setAlpha(0.95);

          const desc = this.add.text(bx+14, by+28, u.desc, {
            fontFamily:'system-ui, -apple-system, Segoe UI, Roboto, Arial',
            fontSize:'12px',
            color:'#d9d1ff'
          }).setAlpha(0.72);

          r.setInteractive({ useHandCursor:false })
            .on('pointerdown', ()=>{
              // apply
              u.apply();
              this.pop(this.player.x, this.player.y, 0x8a4dff);
              // close
              overlay.destroy(); card.destroy(); title.destroy();
              btns.forEach(o=>o.destroy());
              name.destroy(); desc.destroy(); // might have been destroyed in btns, keep safe?
              this.upgradeOpen = false;
            });

          btns.push(r, name, desc);
        }

        this.upgradeUI = { overlay, card, title, btns };
      }

      buildUpgrades(){
        // weighted-ish, but simple
        const list = [
          {
            name: "+DMG",
            desc: `Damage +20%`,
            apply: ()=> { this.damage = Math.round(this.damage * 1.2); }
          },
          {
            name: "+FIRE RATE",
            desc: `Fire rate +25%`,
            apply: ()=> { this.fireRate = Math.min(18, this.fireRate * 1.25); }
          },
          {
            name: "+HP MAX",
            desc: `Max HP +25 (heal +25)`,
            apply: ()=> { this.hpMax += 25; this.hp = Math.min(this.hpMax, this.hp + 25); }
          },
          {
            name: "+MOVE",
            desc: `Move speed +18%`,
            apply: ()=> { this._moveMul = (this._moveMul || 1) * 1.18; }
          },
          {
            name: "PIERCING",
            desc: `Bullets live longer (+35%)`,
            apply: ()=> { this._bulletLifeMul = (this._bulletLifeMul || 1) * 1.35; }
          },
          {
            name: "ULT CHARGE",
            desc: `Ult charges faster (+40%)`,
            apply: ()=> { this._ultMul = (this._ultMul || 1) * 1.4; }
          },
        ];

        // pick 3 random unique
        Phaser.Utils.Array.Shuffle(list);
        return list.slice(0,3);
      }

      updateHud(){
        const ultPct = Math.round(this.ultCharge * 100);
        const ultText = this.ultReady ? `${this.ultName}: READY` : `${this.ultName}: ${ultPct}%`;
        this.hudEl.textContent =
          `HP: ${this.hp}/${this.hpMax}  |  LVL: ${this.level}  |  WAVE: ${this.wave}\n` +
          `Kills: ${this.kills}  |  ${ultText}`;
      }

      gameOver(){
        // reset
        const t = this.add.text(this.W/2, this.H/2 - 10, "GAME OVER", {
          fontFamily:'system-ui, -apple-system, Segoe UI, Roboto, Arial',
          fontSize:'28px',
          color:'#ffffff'
        }).setOrigin(0.5).setAlpha(0);

        const s = this.add.text(this.W/2, this.H/2 + 26, "Tap to restart", {
          fontFamily:'system-ui, -apple-system, Segoe UI, Roboto, Arial',
          fontSize:'14px',
          color:'#d9d1ff'
        }).setOrigin(0.5).setAlpha(0);

        this.tweens.add({ targets:[t,s], alpha:0.95, duration:180 });

        this.input.once('pointerdown', ()=>{
          location.reload();
        });
      }

      update(time, dt){
        const delta = dt / 1000;
        if (!this.player) return;

        // if upgrade open, we still animate particles etc but pause gameplay
        const paused = this.upgradeOpen;

        // movement
        const baseMove = 210;
        const moveMul = this._moveMul || 1;
        if (!paused){
          this.player.x += this.joyVec.x * baseMove * moveMul * delta;
          this.player.y += this.joyVec.y * baseMove * moveMul * delta;
          this.clampToArena(this.player);
        }

        // spawn enemies for wave
        if (!paused){
          this.spawnTimer -= delta;
          if (this.waveSpawned < this.waveAliveTarget){
            if (this.spawnTimer <= 0){
              this.spawnEnemy();
              this.waveSpawned++;
              this.spawnTimer = Math.max(0.08, 0.42 - this.wave*0.015);
            }
          }
        }

        // enemy AI + contact damage
        if (!paused){
          const px=this.player.x, py=this.player.y;
          this.enemies.getChildren().forEach(e=>{
            if (!e.active) return;
            const ang = Phaser.Math.Angle.Between(e.x,e.y,px,py);
            e.x += Math.cos(ang) * e.spd * delta;
            e.y += Math.sin(ang) * e.spd * delta;

            // touch damage with invuln
            const d = dist(e.x,e.y,px,py);
            if (d < (22 * (e.scaleX||1)) && this.player.inv <= 0){
              this.hp -= e.dmg;
              this.player.inv = 0.7;
              this.cameras.main.shake(90, 0.0045);
              if (navigator.vibrate) navigator.vibrate(25);
              this.pop(px,py, 0xff4d6d);
              if (this.hp <= 0){
                this.updateHud();
                this.gameOver();
              }
            }
          });
          this.player.inv -= delta;
        }

        // auto shooting
        if (!paused && this.hp > 0){
          const { e, d } = this.findNearestEnemy();
          if (e && d <= this.range){
            const interval = 1000 / this.fireRate;
            if (time - this.lastShot >= interval){
              this.lastShot = time;
              this.shootAt(e);
            }
          }
        }

        // bullets update + hit
        const lifeMul = this._bulletLifeMul || 1;
        if (!paused){
          this.bullets.getChildren().forEach(b=>{
            if (!b.active) return;
            b.x += b.vx * delta;
            b.y += b.vy * delta;
            b.life -= delta;

            // out of arena or dead
            if (b.life <= 0 ||
                b.x < this.arena.x-40 || b.x > this.arena.x+this.arena.w+40 ||
                b.y < this.arena.y-40 || b.y > this.arena.y+this.arena.h+40){
              b.destroy();
              return;
            }

            // hit check (simple)
            let hit = null;
            this.enemies.getChildren().forEach(e=>{
              if (hit || !e.active) return;
              const d = dist(b.x,b.y,e.x,e.y);
              if (d < 14*(e.scaleX||1)){
                hit = e;
              }
            });

            if (hit){
              hit.hp -= b.dmg;
              this.pop(hit.x, hit.y, 0xff66f5);
              // pierce: bullets live longer if upgrade; else die
              if (lifeMul <= 1.01){
                b.destroy();
              } else {
                b.life = Math.min(b.life, 0.22 * lifeMul);
              }

              if (hit.hp <= 0){
                this.killEnemy(hit);
              }
            }
          });
        }

        // ult cooldown cosmetic
        if (this.ultCooldown > 0) this.ultCooldown = Math.max(0, this.ultCooldown - delta);

        // faster ult charging upgrade
        const ultMul = this._ultMul || 1;
        if (!this.ultReady && ultMul > 1 && !paused){
          // tiny passive charge to feel smoother
          this.ultCharge = clamp(this.ultCharge + 0.004 * (ultMul-1) * delta * 60, 0, 1);
          if (this.ultCharge >= 1) this.ultReady = true;
        }

        // check wave clear
        if (!paused){
          const alive = this.enemies.getChildren().filter(e=>e.active).length;
          if (this.waveSpawned >= this.waveAliveTarget && alive === 0){
            this.wave++;
            // small heal between waves
            this.hp = Math.min(this.hpMax, this.hp + 10);
            this.waveIntro();
          }
        }

        this.updateHud();
      }
    }

    const config = {
      type: Phaser.AUTO,
      parent: 'game',
      width: window.innerWidth,
      height: window.innerHeight,
      backgroundColor: '#07060a',
      scene: [GameScene],
      scale: { mode: Phaser.Scale.RESIZE, autoCenter: Phaser.Scale.CENTER_BOTH }
    };

    const game = new Phaser.Game(config);
    window.addEventListener('resize', ()=> game.scale.resize(window.innerWidth, window.innerHeight));
  </script>
</body>
</html>
